

大多数计算机使用8位的块，或者{{c1::**字节**}}（byte),作为最小的可寻址的内存单位，而不是访问内存中单独的位。
<!--ID: 1722020080371-->


机器级程序将内存视为一个非常大的字节数组，称为{{c1::**虚拟内存**}}(virtualmemory)
<!--ID: 1722020080373-->


内存的每个字节都由一个唯一的数字来标识，称为它的{{c1::地址}}（address)
所有可能地址的集合就称为{{c2::虚拟地址空间}}（virtualaddressspace)
<!--ID: 1722020080375-->


顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现（见第9章）是将动态随机访问存储器(DRAM) 闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。

在接下来的几章中，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的**程序对象**（program object),即程序数据、指令和控制信息。

可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。

例如，C语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象)都是某个存储块的第一个字节的虚拟地址。

C编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。

尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。

每个**程序对象**可以简单地视为一个{{c1::**字节块**}}，而程序本身就是一个{{c1::**字节序列**}}。
<!--ID: 1722020080376-->



## 1	16进制表示法

一个字节由 8 位组成。在二进制表示法中，它的值域是 $00000000_2--11111111_2$ 。如果看 成十进制整数，它的值域就是 $0_{10}-255_{10}$两种符号表示法对于描述位模式来说都不是非常方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是，以16为基数，或者叫做十六进制（hexadecimal)数，来表示**位模式**。
![[信息存储-20240726112607627.webp]]
<!--ID: 1722020080379-->



## 2	字数据大小

每台计算机都有一个{{c1::字长}}（word size),指明指针数据的{{c1::标称大小}}(nominal size)
<!--ID: 1722020080380-->


因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的{{c1::最大大小}}。
<!--ID: 1722020080382-->


也就是说，对于一个字长为w位的机器而言，虚拟地址的范围为$0〜2^{w}—1$，程序最多访问$2^w$个字节。32位字长限制虚拟地址空间为4千兆字节(写作4GB),也就是说，刚刚超过$4X10^9$字节。扩展到 64 位字长使得虚拟地址空间为 16EB, 大约是 $1.84 * 10^{19}$字节。
<!--ID: 1722020080384-->



C语言支持整数和浮点数的多种数据格式
整数或者为有符号的，即可以表示负数、零和正数；或者为无符号的，即只能表示非负数。

## 3	寻址和字节顺序


{{c1::小端法}}书写字节序列的自然方式是{{c1::最低位字节}}在左边(低地址)，而最高位字节在右边(高地址)，这正好和通常书写数字时最高有效位在左边，最低有效位在右边的方式相反
<!--ID: 1722020080386-->






- 🍅 (pomodoro::WORK) (duration:: 60m) (begin:: 2024-07-26 10:22) - (end:: 2024-07-26 11:22)