## 1	冒泡

你可以通过自己实现排序算法来对二维列表进行排序。这里我们可以使用冒泡排序（Bubble Sort）算法来实现按`c`项（即每个子列表的第三个元素）由大到小排序。

下面是代码实现：

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            # 比较相邻的c项值
            if arr[j][2] < arr[j+1][2]:
                # 交换子列表
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

arr = [
    ["a1", "b1", "c1", "d1"],
    ["a2", "b2", "c2", "d2"],
    ["a3", "b3", "c3", "d3"],
    ["a4", "b4", "c4", "d4"]
]

# 将c1, c2, c3, c4替换为实际数值以便排序
values = [
    [1, 2, 9, 4],
    [1, 5, 7, 2],
    [1, 6, 8, 3],
    [1, 4, 6, 1]
]

sorted_arr = bubble_sort(values)

print("排序后的二维列表：")
for row in sorted_arr:
    print(row)
```

### 代码解释：
1. **Bubble Sort**: 冒泡排序通过反复比较相邻的元素并交换它们的位置，将较大的元素逐步“冒泡”到列表的末尾。在这里，我们是按每个子列表的第三个元素（即`c`项）进行比较。

2. **排序过程**: 外层循环遍历整个列表，内层循环比较相邻的元素，如果前一个元素的`c`项值小于后一个元素的`c`项值，则交换它们的位置。

3. **输出结果**: 输出的是按`c`项值从大到小排序后的二维列表。

### 输出示例：
假设我们使用的`values`如下：

```python
[
    [1, 2, 9, 4],
    [1, 5, 7, 2],
    [1, 6, 8, 3],
    [1, 4, 6, 1]
]
```

排序后的二维列表将会是：

```python
[
    [1, 2, 9, 4],
    [1, 6, 8, 3],
    [1, 5, 7, 2],
    [1, 4, 6, 1]
]
```

这种方法完全符合要求，即只使用了基本的列表操作而未使用`sort`方法或第三方库。